#!/usr/bin/env python3
# Copyright 2017 by Alexis Pietak & Cecil Curry.
# See "LICENSE" for further details.

'''
Classes defining this application's graphical user interface (GUI).
'''

#FIXME: To simplify future localization efforts, all human-readable strings to
#be displayed should be filtered through the Qt translate() function. Note that
#the external "pyside2-lupdate" command will probably need to be called to
#convert raw translation files into importable Python modules.

# ....................{ IMPORTS                            }....................
from betsee import pathtree
from betsee.lib.pyside import psdrc, psdui

# ....................{ GLOBALS                            }....................
#FIXME: PySide and hence presumably PySide2 as well lacks an analogue to the
#loadUiType() function. To circumvent this, consider defining our own
#loadUiType() function performing the equivalent thereof. This is low-hanging
#fruit. Since doing so on every GUI startup is presumably inefficient, however,
#this should also be improved in the long-term to perform caching: namely,
#
#* On the first execution of the GUI:
#  1. Convert the UI file referenced below into in-memory Python code.
#  2. Convert that code into a Python file, presumably cached in the current
#     dot directory for BETSE (e.g., "~/.betse/").
#* On all subsequent executions of the GUI:
#  1. Compare the time stamps of this UI file and this cached Python file.
#  2. If the time stamps are the same, reuse the latter as is.
#  3. Else, recreate the latter as above and use the newly cached file.

# ....................{ CLASSES                            }....................
class BetseeGUI(object):
    '''
    Graphical user interface (GUI) for this application, doubling as both the
    main window and root Qt widget for this application.
    '''

    # ..................{ INITIALIZERS                       }..................
    def __init__(self, *args, **kwargs) -> None:

        # Initialize our superclass with all passed parameters.
        super().__init__(*args, **kwargs)

        #FIXME: Convert BETSEE's QRC file to a Python file *BEFORE* converting
        #its UI file to a Python type below. Sadly, the code generated by the
        #latter conversion appears to expect the Python file generated by the
        #former conversion to be a top-level module importable at the top-level
        #of the Python package tree (!): e.g.,
        #
        #    # The last line of the code generated by the latter conversion.
        #    import betsee_rc
        #
        #Incidentally, an upstream issue should probably be filed about this.
        #Only Python 2.x supports such implicit relative imports. Under Python
        #3.x, all relative imports are required to be explicit: e.g.,
        #
        #    from . import betsee_rc
        #
        #Clearly, however, we want neither of the import statements above. This
        #implies that we'll probably need to perform a regex-based replacement
        #of all lines matching "^import (\w+)_rc$" and replacing them with
        #something instead resembling "import betsee.data.qrc.$1_rc". That said,
        #we'll probably want to generate the temporary "betsee_rc" in a
        #"~/.betse/betsee_cache/" dot subdirectory -- which means that we'll
        #want to append "~/.betse/betsee_cache/" to the "sys.path" list, which
        #would then permit us to import such generated modules as
        #"from betsee_cache import $1_rc".
        #
        #It's not going to be particularly pretty, but we see little
        #alternatives here. Actually, rather than performing an after-the-fact
        #regular expression replacement, it *SHOULD* be feasible to monkey-patch
        #the "pyside2uic" codebase before-the-fact to coerce the compiler to
        #emit *EXACTLY* the code we require. Let's examine this aveneu first.
        #
        #Hmm; yes. We see. The pyside2uic.uiparser.UIParser.readResources()
        #method performs the desired operation. We *COULD* monkey-patch this
        #method, but doing so would be considerably more fragile than simply
        #modifying the resulting string after-the-fact. Fragility is bad. Let's
        #go with the regex-based replacement, please.
        #FIXME: Actually, regex-based replacement is insane. Instead, simply do
        #the following:
        #
        #* Add pathtree.get_dot_py_dirname() to "sys.path".
        #* Manually modify the XML contents of pathtree.get_data_ui_filename()
        #  now (i.e., not at runtime) to ensure that the resource file is named
        #  "betsee.qrc". Right. O.K.; that's already done. Great!

        psdrc.convert_qrc_file_to_py_file_cached(
            qrc_filename=pathtree.get_data_qrc_filename(),
            py_filename=pathtree.get_dot_py_qrc_filename())

        # UI class generated from the XML-formatted Qt Designer file specifying
        # the non-dynamic core of the BETSEE GUI (i.e., excluding dynamic
        # signals and slots), which requires Python logic.
        ui_class = psdui.convert_ui_file_to_class_cached(
            ui_filename=pathtree.get_data_ui_filename())

        #FIXME: Do something with "ui_class" here, presumably resembling:
        #
        #* Define a new "BetseeMainWindow" class inheriting from both "ui_class"
        #  and "ui_class.BASE_CLASS" in the correct order. The significant issue
        #  here is... in which scope should this class be defined? Ideally, it
        #  would be defined at the top-level scope -- but, of course, we can't
        #  do that, because we require the "ui_class" variable. We can, of
        #  course, declare this class as an inner class defined here at this
        #  indentation level -- but that, of course, would become cumbersome
        #  painfully quickly. The ideal approach is probably to acknowledge that
        #  "ui_class" is effectively a global singleton for the lifetime of this
        #  application by:
        #  * Defining a new "betsee.lib.pyside.psdglobal" submodule containing
        #    all PySide-specific global (ideally, singleton) variables. This
        #    submodule is distinct from the special "betsee.lib.pyside.psdapp"
        #    submodule, which provides *ONLY* the "APP_WIDGET" global in a safe
        #    manner *NOT* importing from BETSE submodules. The "psdglobal"
        #    submodule is under no such constraints and may (indeed, should)
        #    safely import from BETSE submodules. If not for this
        #    chicken-and-egg constraint, these two submodules would ideally be
        #    conjoined. They cannot be. Document this subtle issue...somewhere.
        #  * Declaring a "MAIN_WINDOW_UI_CLASS" global at the top-level of the
        #    "betsee.lib.pyside.psdapp" submodule initialized to "None".
        #  * Defining a set_main_window_ui_class() convenience function in that
        #    submodule setting that global, which should be called here to do
        #    so immediately. As a safety check, this function should raise an
        #    exception if that global is non-None (i.e., this function should
        #    only be called once per application).
        #  * Defining a get_main_window_ui_class() convenience function in that
        #    submodule getting that global. As a safety check, this function
        #    should raise an exception if that global is None.
        #  * Defining a new "betse.gui.guimainwindow" submodule.
        #  * Importing that submodule here *ONLY* after calling the
        #    set_main_window_ui_class() function.
        #  * In that submodule, importing
        #    "betsee.lib.pyside.psdapp" and calling the
        #    psdapp.get_main_window_ui_class() function *AT THE TOP LEVEL.*
        #    This, of course, is the key to the universe of fun.
        #  * Define the BetseeMainWindow.__init__() method to call the
        #    setupUi() method inherited from this UI class, passing itself as
        #    the only parameter. (Wacky, but that's PySide.)
        #* Instantiate this "BetseeMainWindow" class here.
